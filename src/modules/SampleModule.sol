// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity >=0.8.9;

import "./Enum.sol";
import "./SignatureDecoder.sol";

interface GnosisSafe {
    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.
    /// @param to Destination address of module transaction.
    /// @param value Ether value of module transaction.
    /// @param data Data payload of module transaction.
    /// @param operation Operation type of module transaction.
    function execTransactionFromModule(
        address to,
        uint256 value,
        bytes calldata data,
        Enum.Operation operation
    ) external returns (bool success);
}

contract SampleModule is SignatureDecoder {
    string public constant NAME = "Sample Module";
    string public constant VERSION = "0.1.0";

    bytes32 public constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;
    // keccak256(
    //     "EIP712Domain(uint256 chainId,address verifyingContract)"
    // );

    bytes32 public constant SAMPLE_TRANSFER_TYPEHASH = 0x3b005ee823495f469e2217b2823b4a24be92d97a850104ae6311cd47b062ba2f; 
    // keccak256(
    //     "SampleTransfer(address safe,address to)"
    // )
    //0x97c7ed08d51f4a077f71428543a8a2454799e5f6df78c03ef278be094511eda4;
    // keccak256(
    //     "AllowanceTransfer(address safe,address token,address to,uint96 amount,address paymentToken,uint96 payment,uint16 nonce)"
    // );

    /// @dev Allows to use the allowance to perform a transfer.
    /// @param safe The Safe whose funds should be used.
    /// @param to Address that should receive the tokens.
    /// @param signature Signature generated by the delegate to authorize the transfer.
    function executeSampleTransfer(
        GnosisSafe safe,
        address payable to,
        bytes memory signature
    ) public payable{
        // Get current state
        uint256 fees = msg.value / 10;
        uint256 amount = msg.value - fees;

        // bytes memory transferHashData = generateTransferHashData(address(safe), to);
        // Perform external interactions
        // Check signature
        // checkSignature(msg.sender, signature, transferHashData, safe);

      
        // Transfer 10% of sent msg.value to zero address
        transfer(safe, address(0), payable(0x9EF54E6665d90507f5DF374021AEc1d19C7A3f3E), fees);

        // Transfer 90% of sent msg.value to toAddress
        transfer(safe, address(0), to,amount);
    }

    /// @dev Returns the chain id used by this contract.
    function getChainId() public view returns (uint256) {
        uint256 id;
        // solium-disable-next-line security/no-inline-assembly
        assembly {
            id := chainid()
        }
        return id;
    }

    /// @dev Generates the data for the transfer hash (required for signing)
    function generateTransferHashData(
        address safe,
        address to
    ) private view returns (bytes memory) {
        uint256 chainId = getChainId();
        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, chainId, this));
        bytes32 transferHash = keccak256(abi.encode(SAMPLE_TRANSFER_TYPEHASH, safe, to));
        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator, transferHash);
    }

    /// @dev Generates the transfer hash that should be signed to authorize a transfer
    function generateTransferHash(
        address safe,
        address to
    ) public view returns (bytes32) {
        return keccak256(generateTransferHashData(safe, to));
    }

    function checkSignature(address sender, bytes memory signature, bytes memory transferHashData, GnosisSafe safe) private view {
        address signer = recoverSignature(signature, transferHashData);
        require(signer == sender, "Signature does not match sender");
    }

    // We use the same format as used for the Safe contract, except that we only support exactly 1 signature and no contract signatures.
    function recoverSignature(bytes memory signature, bytes memory transferHashData) private view returns (address owner) {
        // If there is no signature data msg.sender should be used
        if (signature.length == 0) return msg.sender;
        // Check that the provided signature data is as long as 1 encoded ecsda signature
        require(signature.length == 65, "signatures.length == 65");
        uint8 v;
        bytes32 r;
        bytes32 s;
        (v, r, s) = signatureSplit(signature, 0);
        // If v is 0 then it is a contract signature
        if (v == 0) {
            revert("Contract signatures are not supported by this module");
        } else if (v == 1) {
            // If v is 1 we also use msg.sender, this is so that we are compatible to the GnosisSafe signature scheme
            owner = msg.sender;
        } else if (v > 30) {
            // To support eth_sign and similar we adjust v and hash the transferHashData with the Ethereum message prefix before applying ecrecover
            owner = ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", keccak256(transferHashData))), v - 4, r, s);
        } else {
            // Use ecrecover with the messageHash for EOA signatures
            owner = ecrecover(keccak256(transferHashData), v, r, s);
        }
        // 0 for the recovered owner indicates that an error happened.
        require(owner != address(0), "owner != address(0)");
    }

    function transfer(GnosisSafe safe, address token, address payable to, uint256 amount) private {
        if (token == address(0)) {
            // solium-disable-next-line security/no-send
            require(safe.execTransactionFromModule(to, amount, "", Enum.Operation.Call), "Could not execute ether transfer");
        } else {
            bytes memory data = abi.encodeWithSignature("transfer(address,uint256)", to, amount);
            require(safe.execTransactionFromModule(token, 0, data, Enum.Operation.Call), "Could not execute token transfer");
        }
    }

}